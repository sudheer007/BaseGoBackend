package security

import (
	"context"
	"crypto/aes"
	"crypto/cipher"
	"crypto/rand"
	"encoding/base64"
	"errors"
	"fmt"
	"io"
	"sync"
	"time"
)

// KMSProvider defines the type of KMS provider
type KMSProvider string

// Supported KMS providers
const (
	ProviderAWS   KMSProvider = "aws"
	ProviderGCP   KMSProvider = "gcp"
	ProviderAzure KMSProvider = "azure"
	ProviderVault KMSProvider = "vault"
	ProviderLocal KMSProvider = "local" // For development and testing only
)

// KMSConfig holds configuration for a KMS provider
type KMSConfig struct {
	Provider     KMSProvider
	Region       string
	Endpoint     string
	KeyID        string
	Credentials  map[string]string
	CacheEnabled bool
	CacheTTL     time.Duration
}

// KMS errors
var (
	ErrKeyNotFound          = errors.New("key not found")
	ErrInvalidKeyID         = errors.New("invalid key ID")
	ErrUnsupportedProvider  = errors.New("unsupported KMS provider")
	ErrKMSEncryptionFailed  = errors.New("encryption failed")
	ErrKMSDecryptionFailed  = errors.New("decryption failed")
	ErrKeyRotationFailed    = errors.New("key rotation failed")
	ErrInvalidConfiguration = errors.New("invalid KMS configuration")
	ErrAccessDenied         = errors.New("access denied to KMS")
)

// KMSClient defines the interface for interacting with a KMS provider
type KMSClient interface {
	Encrypt(ctx context.Context, plaintext []byte, keyID string) ([]byte, error)
	Decrypt(ctx context.Context, ciphertext []byte, keyID string) ([]byte, error)
	GenerateDataKey(ctx context.Context, keyID string, keySpec string) (DataKey, error)
	ListKeys(ctx context.Context) ([]KeyInfo, error)
	GetKeyInfo(ctx context.Context, keyID string) (KeyInfo, error)
	CreateKey(ctx context.Context, keySpec KeySpec) (KeyInfo, error)
	ScheduleKeyDeletion(ctx context.Context, keyID string, pendingDays int) error
	EnableKey(ctx context.Context, keyID string) error
	DisableKey(ctx context.Context, keyID string) error
	RotateKey(ctx context.Context, keyID string) (KeyInfo, error)
}

// DataKey represents a data key generated by KMS
type DataKey struct {
	Plaintext  []byte
	Ciphertext []byte
	KeyID      string
}

// KeyInfo represents information about a KMS key
type KeyInfo struct {
	KeyID           string
	ARN             string
	CreationDate    time.Time
	Description     string
	Enabled         bool
	KeyRotationDate *time.Time
	KeyState        string
	KeyUsage        string
	Origin          string
}

// KeySpec defines specifications for creating a new key
type KeySpec struct {
	KeyType        string
	Description    string
	KeyUsage       string
	MultiRegion    bool
	Tags           map[string]string
	EnableRotation bool
}

// KMSManager manages interactions with KMS providers
type KMSManager struct {
	clients  map[KMSProvider]KMSClient
	configs  map[KMSProvider]KMSConfig
	keyCache map[string]cachedKey
	mutex    sync.RWMutex
}

// cachedKey represents a cached encryption key
type cachedKey struct {
	keyID     string
	value     []byte
	expiresAt time.Time
}

// NewKMSManager creates a new KMS manager
func NewKMSManager() *KMSManager {
	return &KMSManager{
		clients:  make(map[KMSProvider]KMSClient),
		configs:  make(map[KMSProvider]KMSConfig),
		keyCache: make(map[string]cachedKey),
	}
}

// RegisterProvider registers a KMS provider
func (m *KMSManager) RegisterProvider(config KMSConfig) error {
	m.mutex.Lock()
	defer m.mutex.Unlock()

	client, err := createKMSClient(config)
	if err != nil {
		return err
	}

	m.clients[config.Provider] = client
	m.configs[config.Provider] = config

	return nil
}

// Encrypt encrypts plaintext using the specified KMS provider
func (m *KMSManager) Encrypt(ctx context.Context, plaintext []byte, provider KMSProvider, keyID string) ([]byte, error) {
	m.mutex.RLock()
	client, exists := m.clients[provider]
	config := m.configs[provider]
	m.mutex.RUnlock()

	if !exists {
		return nil, fmt.Errorf("%w: %s", ErrUnsupportedProvider, provider)
	}

	// Use default key if not specified
	if keyID == "" {
		keyID = config.KeyID
	}

	// Encrypt using KMS
	return client.Encrypt(ctx, plaintext, keyID)
}

// Decrypt decrypts ciphertext using the specified KMS provider
func (m *KMSManager) Decrypt(ctx context.Context, ciphertext []byte, provider KMSProvider, keyID string) ([]byte, error) {
	m.mutex.RLock()
	client, exists := m.clients[provider]
	config := m.configs[provider]
	m.mutex.RUnlock()

	if !exists {
		return nil, fmt.Errorf("%w: %s", ErrUnsupportedProvider, provider)
	}

	// Use default key if not specified
	if keyID == "" {
		keyID = config.KeyID
	}

	// Decrypt using KMS
	return client.Decrypt(ctx, ciphertext, keyID)
}

// GenerateDataKey generates a data key using the specified KMS provider
func (m *KMSManager) GenerateDataKey(ctx context.Context, provider KMSProvider, keyID, keySpec string) (DataKey, error) {
	m.mutex.RLock()
	client, exists := m.clients[provider]
	config := m.configs[provider]
	m.mutex.RUnlock()

	if !exists {
		return DataKey{}, fmt.Errorf("%w: %s", ErrUnsupportedProvider, provider)
	}

	// Use default key if not specified
	if keyID == "" {
		keyID = config.KeyID
	}

	// Generate data key using KMS
	return client.GenerateDataKey(ctx, keyID, keySpec)
}

// GetCachedDataKey gets a cached data key or generates a new one
func (m *KMSManager) GetCachedDataKey(ctx context.Context, provider KMSProvider, keyID, keySpec string) (DataKey, error) {
	m.mutex.RLock()
	config, exists := m.configs[provider]
	m.mutex.RUnlock()

	if !exists {
		return DataKey{}, fmt.Errorf("%w: %s", ErrUnsupportedProvider, provider)
	}

	// Use default key if not specified
	if keyID == "" {
		keyID = config.KeyID
	}

	// Check if caching is enabled
	if config.CacheEnabled {
		m.mutex.RLock()
		cachedKey, exists := m.keyCache[keyID]
		m.mutex.RUnlock()

		// Return cached key if it exists and hasn't expired
		if exists && time.Now().Before(cachedKey.expiresAt) {
			return DataKey{
				Plaintext: cachedKey.value,
				KeyID:     keyID,
			}, nil
		}
	}

	// Generate a new data key
	dataKey, err := m.GenerateDataKey(ctx, provider, keyID, keySpec)
	if err != nil {
		return DataKey{}, err
	}

	// Cache the data key if caching is enabled
	if config.CacheEnabled {
		m.mutex.Lock()
		m.keyCache[keyID] = cachedKey{
			keyID:     keyID,
			value:     dataKey.Plaintext,
			expiresAt: time.Now().Add(config.CacheTTL),
		}
		m.mutex.Unlock()
	}

	return dataKey, nil
}

// RotateKey rotates a KMS key
func (m *KMSManager) RotateKey(ctx context.Context, provider KMSProvider, keyID string) (KeyInfo, error) {
	m.mutex.RLock()
	client, exists := m.clients[provider]
	config := m.configs[provider]
	m.mutex.RUnlock()

	if !exists {
		return KeyInfo{}, fmt.Errorf("%w: %s", ErrUnsupportedProvider, provider)
	}

	// Use default key if not specified
	if keyID == "" {
		keyID = config.KeyID
	}

	// Rotate key using KMS
	keyInfo, err := client.RotateKey(ctx, keyID)
	if err != nil {
		return KeyInfo{}, err
	}

	// Invalidate cache for this key
	m.mutex.Lock()
	delete(m.keyCache, keyID)
	m.mutex.Unlock()

	return keyInfo, nil
}

// ListKeys lists keys from the specified KMS provider
func (m *KMSManager) ListKeys(ctx context.Context, provider KMSProvider) ([]KeyInfo, error) {
	m.mutex.RLock()
	client, exists := m.clients[provider]
	m.mutex.RUnlock()

	if !exists {
		return nil, fmt.Errorf("%w: %s", ErrUnsupportedProvider, provider)
	}

	return client.ListKeys(ctx)
}

// createKMSClient creates a KMS client based on the provider
func createKMSClient(config KMSConfig) (KMSClient, error) {
	switch config.Provider {
	case ProviderAWS:
		return newAWSKMSClient(config)
	case ProviderGCP:
		return newGCPKMSClient(config)
	case ProviderAzure:
		return newAzureKMSClient(config)
	case ProviderVault:
		return newVaultKMSClient(config)
	case ProviderLocal:
		return newLocalKMSClient(config)
	default:
		return nil, fmt.Errorf("%w: %s", ErrUnsupportedProvider, config.Provider)
	}
}

// Mock implementations for different KMS providers

// LocalKMSClient is a mock KMS client for local development and testing
type LocalKMSClient struct {
	keys  map[string][]byte
	mutex sync.RWMutex
}

func newLocalKMSClient(config KMSConfig) (*LocalKMSClient, error) {
	return &LocalKMSClient{
		keys: make(map[string][]byte),
	}, nil
}

func (c *LocalKMSClient) Encrypt(_ context.Context, plaintext []byte, keyID string) ([]byte, error) {
	c.mutex.RLock()
	key, exists := c.keys[keyID]
	c.mutex.RUnlock()

	if !exists {
		// Generate a random key for development purposes
		key = make([]byte, 32)
		if _, err := io.ReadFull(rand.Reader, key); err != nil {
			return nil, fmt.Errorf("%w: %v", ErrKMSEncryptionFailed, err)
		}

		c.mutex.Lock()
		c.keys[keyID] = key
		c.mutex.Unlock()
	}

	// Create AES cipher
	block, err := aes.NewCipher(key)
	if err != nil {
		return nil, fmt.Errorf("%w: %v", ErrKMSEncryptionFailed, err)
	}

	// Create GCM
	gcm, err := cipher.NewGCM(block)
	if err != nil {
		return nil, fmt.Errorf("%w: %v", ErrKMSEncryptionFailed, err)
	}

	// Create a nonce
	nonce := make([]byte, gcm.NonceSize())
	if _, err := io.ReadFull(rand.Reader, nonce); err != nil {
		return nil, fmt.Errorf("%w: %v", ErrKMSEncryptionFailed, err)
	}

	// Encrypt
	ciphertext := gcm.Seal(nonce, nonce, plaintext, nil)
	return ciphertext, nil
}

func (c *LocalKMSClient) Decrypt(_ context.Context, ciphertext []byte, keyID string) ([]byte, error) {
	c.mutex.RLock()
	key, exists := c.keys[keyID]
	c.mutex.RUnlock()

	if !exists {
		return nil, ErrKeyNotFound
	}

	// Create AES cipher
	block, err := aes.NewCipher(key)
	if err != nil {
		return nil, fmt.Errorf("%w: %v", ErrKMSDecryptionFailed, err)
	}

	// Create GCM
	gcm, err := cipher.NewGCM(block)
	if err != nil {
		return nil, fmt.Errorf("%w: %v", ErrKMSDecryptionFailed, err)
	}

	// Extract nonce and ciphertext
	nonceSize := gcm.NonceSize()
	if len(ciphertext) < nonceSize {
		return nil, fmt.Errorf("%w: ciphertext too short", ErrKMSDecryptionFailed)
	}

	nonce, ciphertext := ciphertext[:nonceSize], ciphertext[nonceSize:]

	// Decrypt
	plaintext, err := gcm.Open(nil, nonce, ciphertext, nil)
	if err != nil {
		return nil, fmt.Errorf("%w: %v", ErrKMSDecryptionFailed, err)
	}

	return plaintext, nil
}

func (c *LocalKMSClient) GenerateDataKey(_ context.Context, keyID string, _ string) (DataKey, error) {
	// Generate a random data key
	plaintext := make([]byte, 32)
	if _, err := io.ReadFull(rand.Reader, plaintext); err != nil {
		return DataKey{}, fmt.Errorf("failed to generate data key: %v", err)
	}

	// Encrypt the data key
	ciphertext, err := c.Encrypt(context.Background(), plaintext, keyID)
	if err != nil {
		return DataKey{}, err
	}

	return DataKey{
		Plaintext:  plaintext,
		Ciphertext: ciphertext,
		KeyID:      keyID,
	}, nil
}

func (c *LocalKMSClient) ListKeys(_ context.Context) ([]KeyInfo, error) {
	c.mutex.RLock()
	defer c.mutex.RUnlock()

	keys := make([]KeyInfo, 0, len(c.keys))
	for keyID := range c.keys {
		keys = append(keys, KeyInfo{
			KeyID:        keyID,
			CreationDate: time.Now(),
			Enabled:      true,
			KeyState:     "Enabled",
			KeyUsage:     "ENCRYPT_DECRYPT",
			Origin:       "LOCAL",
		})
	}

	return keys, nil
}

func (c *LocalKMSClient) GetKeyInfo(_ context.Context, keyID string) (KeyInfo, error) {
	c.mutex.RLock()
	_, exists := c.keys[keyID]
	c.mutex.RUnlock()

	if !exists {
		return KeyInfo{}, ErrKeyNotFound
	}

	return KeyInfo{
		KeyID:        keyID,
		CreationDate: time.Now(),
		Enabled:      true,
		KeyState:     "Enabled",
		KeyUsage:     "ENCRYPT_DECRYPT",
		Origin:       "LOCAL",
	}, nil
}

func (c *LocalKMSClient) CreateKey(_ context.Context, keySpec KeySpec) (KeyInfo, error) {
	keyID := fmt.Sprintf("local-key-%d", time.Now().UnixNano())

	// Generate a random key
	key := make([]byte, 32)
	if _, err := io.ReadFull(rand.Reader, key); err != nil {
		return KeyInfo{}, fmt.Errorf("failed to generate key: %v", err)
	}

	c.mutex.Lock()
	c.keys[keyID] = key
	c.mutex.Unlock()

	return KeyInfo{
		KeyID:        keyID,
		CreationDate: time.Now(),
		Description:  keySpec.Description,
		Enabled:      true,
		KeyState:     "Enabled",
		KeyUsage:     keySpec.KeyUsage,
		Origin:       "LOCAL",
	}, nil
}

func (c *LocalKMSClient) ScheduleKeyDeletion(_ context.Context, keyID string, _ int) error {
	c.mutex.Lock()
	defer c.mutex.Unlock()

	if _, exists := c.keys[keyID]; !exists {
		return ErrKeyNotFound
	}

	delete(c.keys, keyID)
	return nil
}

func (c *LocalKMSClient) EnableKey(_ context.Context, keyID string) error {
	c.mutex.RLock()
	_, exists := c.keys[keyID]
	c.mutex.RUnlock()

	if !exists {
		return ErrKeyNotFound
	}

	return nil
}

func (c *LocalKMSClient) DisableKey(_ context.Context, keyID string) error {
	c.mutex.RLock()
	_, exists := c.keys[keyID]
	c.mutex.RUnlock()

	if !exists {
		return ErrKeyNotFound
	}

	return nil
}

func (c *LocalKMSClient) RotateKey(_ context.Context, keyID string) (KeyInfo, error) {
	c.mutex.RLock()
	_, exists := c.keys[keyID]
	c.mutex.RUnlock()

	if !exists {
		return KeyInfo{}, ErrKeyNotFound
	}

	// Generate a new key
	key := make([]byte, 32)
	if _, err := io.ReadFull(rand.Reader, key); err != nil {
		return KeyInfo{}, fmt.Errorf("%w: %v", ErrKeyRotationFailed, err)
	}

	c.mutex.Lock()
	c.keys[keyID] = key
	c.mutex.Unlock()

	now := time.Now()
	return KeyInfo{
		KeyID:           keyID,
		CreationDate:    now,
		Enabled:         true,
		KeyRotationDate: &now,
		KeyState:        "Enabled",
		KeyUsage:        "ENCRYPT_DECRYPT",
		Origin:          "LOCAL",
	}, nil
}

// Stub implementations for other KMS providers
// In a real implementation, these would be fully implemented

func newAWSKMSClient(config KMSConfig) (KMSClient, error) {
	// This would use the AWS SDK to create a KMS client
	return nil, errors.New("AWS KMS client not implemented")
}

func newGCPKMSClient(config KMSConfig) (KMSClient, error) {
	// This would use the GCP SDK to create a KMS client
	return nil, errors.New("GCP KMS client not implemented")
}

func newAzureKMSClient(config KMSConfig) (KMSClient, error) {
	// This would use the Azure SDK to create a KMS client
	return nil, errors.New("Azure KMS client not implemented")
}

func newVaultKMSClient(config KMSConfig) (KMSClient, error) {
	// This would use the Vault SDK to create a KMS client
	return nil, errors.New("Vault KMS client not implemented")
}

// EncryptWithKMS encrypts data with KMS and encodes it as base64
func EncryptWithKMS(ctx context.Context, kms *KMSManager, provider KMSProvider, keyID string, plaintext string) (string, error) {
	ciphertext, err := kms.Encrypt(ctx, []byte(plaintext), provider, keyID)
	if err != nil {
		return "", err
	}
	return base64.StdEncoding.EncodeToString(ciphertext), nil
}

// DecryptWithKMS decrypts base64-encoded data with KMS
func DecryptWithKMS(ctx context.Context, kms *KMSManager, provider KMSProvider, keyID string, encryptedBase64 string) (string, error) {
	ciphertext, err := base64.StdEncoding.DecodeString(encryptedBase64)
	if err != nil {
		return "", fmt.Errorf("failed to decode base64: %v", err)
	}
	plaintext, err := kms.Decrypt(ctx, ciphertext, provider, keyID)
	if err != nil {
		return "", err
	}
	return string(plaintext), nil
}
